% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/1-SymmetryElements.R
\name{transform_symmetry_axis}
\alias{transform_symmetry_axis}
\title{Apply a 3D transformation to a ProperRotationAxis}
\usage{
transform_symmetry_axis(x, transformation, ...)
}
\arguments{
\item{x}{A \code{\link{ProperRotationAxis}} object.}

\item{transformation}{A function that takes a length-3 coordinate and returns a
transformed length-3 coordinate. The input will be passed as a named numeric
vector \code{c(x=..., y=..., z=...)}. The function must return either:
\itemize{
\item a named numeric vector with names \code{x}, \code{y}, \code{z}, or
\item a list with elements \code{x}, \code{y}, \code{z} coercible to numeric.
}}

\item{...}{Additional arguments forwarded to \code{transformation}.}
}
\value{
The same \code{ProperRotationAxis} object \code{x} with updated \code{posA} and \code{posB}.
}
\description{
Applies a user-supplied transformation function to the two endpoints (\code{posA}, \code{posB})
that define a \code{\link{ProperRotationAxis}} line in 3D. This is useful for translating, rotating, or
otherwise mapping the axis to a new position/orientation in space. The symmetry order
\code{Cn} is left unchanged.
}
\details{
The transformation is applied independently to \code{posA} and \code{posB}. No attempt is made
to renormalize or reorder points; the function simply replaces both endpoints with
their transformed coordinates. It is the caller's responsibility to ensure the
transformation preserves distinct endpoints and yields finite numeric results.
}
\examples{
# Define an axis along +Z through the origin
ax <- ProperRotationAxis(Cn = 3L, posA = c(0,0,0), posB = c(0,0,1))

# 1) Translate by (+1, +2, +3)
translate <- function(p, dx=0, dy=0, dz=0) {
  c(x = p["x"] + dx, y = p["y"] + dy, z = p["z"] + dz)
}
ax_t <- transform_symmetry_axis(ax, translate, dx = 1, dy = 2, dz = 3)

# 2) Rotate around Z by 90 degrees about the origin
rotate_z <- function(p, theta) {
  c(x =  cos(theta)*p["x"] - sin(theta)*p["y"],
    y =  sin(theta)*p["x"] + cos(theta)*p["y"],
    z =  p["z"])
}
ax_r <- transform_symmetry_axis(ax, rotate_z, theta = pi/2)

# 3) A transform that returns a list is also accepted
as_list <- function(p) list(x = p["x"] + 1, y = p["y"], z = p["z"])
ax_l <- transform_symmetry_axis(ax, as_list)

}
